# getComputeState Endpoint

## Overview
Looks up a machine record in Firestore by its Google Compute Engine identifier and returns the latest known state for that compute workload. Use this endpoint to poll provisioning progress after invoking `createCompute`. When the calculation kernel is running on the VM, this endpoint can also retrieve kernel log files to monitor simulation progress.

## URL
`GET https://us-central1-optum-80593.cloudfunctions.net/getComputeState`

> Update the host/region if your Firebase Functions deploy to a different project.

## Authentication
Authentication is performed via the license key / customerId. Requests are validated against the customer account associated with the requested compute resource.

## Request Parameters
Parameters may be provided as query string values (`GET`) or JSON payload (`POST`).

| Parameter | Location | Required | Description |
|-----------|----------|----------|-------------|
| `computid` | query/body | ✅ | Google Compute Engine numeric ID returned as `computeId` from `createCompute`. The alias `computeId` is also accepted. |
| `includeLogs` | query/body | ❌ | Set to `true` to include machine logs in the response. Logs are returned as a string. Defaults to `false`. |

## Behaviour
- Searches the `machines` collection for the first document where `gceId == computid`.
- When found, returns the current `state`, customer, requested type, and the timestamp of the last state update.
- If the compute ID is unknown, the function responds with HTTP `404` and `{ "error": "Compute not found" }`.

## Example Request
```
GET /getComputeState?computid=5224090039679406817 HTTP/1.1
Host: us-central1-optum-80593.cloudfunctions.net
```

### Sample Response
```json
{
  "computeId": "5224090039679406817",
  "machineName": "vm-cust-t22vdticn81-ll2raa",
  "state": "booting",
  "customer": "T22VDtiCN81Ryjvawibt",
  "requestedType": "fast",
  "lastStateChange": 1710605518123
}
```

## Error Responses
| Status | When | Payload |
|--------|------|---------|
| 400 | `computid` missing or blank | `{ "error": "computid is required" }` |
| 404 | No machine document matches the supplied ID | `{ "error": "Compute not found" }` |
| 405 | HTTP verb other than GET/POST | `{ "error": "Method not allowed" }` |
| 500 | Firestore query failed | `{ "error": "Failed to load compute state" }` |

## Notes
- The `lastStateChange` value surfaces whichever timestamp is available, preferring `lastProvisionUpdate`, then `datetime`, then provision/start times.
- `state` falls back to `"unknown"` if the machine document has not yet recorded a lifecycle state.
- `requestedType` reflects the friendly choice (`fast`, `very fast`, or `fastest`). Use Firestore's `resolvedMachineType` field if you need the exact GCE SKU name.
- Additional metadata such as `meshFilePath`, `projectFilePath`, or `projectDefinition` appears when the VM was created with the new payload.
- Once the state transitions to `completed`, call `getSimulationResults` to obtain the signed download link for the uploaded result archive.
- When `includeLogs=true`, the response includes log files generated by the calculation kernel running on the VM. These logs contain simulation progress, convergence status, and any runtime errors from `calculationKernel.exe`.

## C++ Example
```cpp
#include <iostream>
#include <string>
#include <curl/curl.h>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* userp) {
    userp->append((char*)contents, size * nmemb);
    return size * nmemb;
}

std::string urlEncode(const std::string& value) {
    CURL* curl = curl_easy_init();
    char* encoded = curl_easy_escape(curl, value.c_str(), value.length());
    std::string result(encoded);
    curl_free(encoded);
    curl_easy_cleanup(curl);
    return result;
}

void pollComputeState(const std::string& computeId) {
    std::string url = "https://us-central1-optum-80593.cloudfunctions.net/getComputeState?computid=" + urlEncode(computeId);

    CURL* curl = curl_easy_init();
    if (!curl) {
        std::cerr << "Failed to initialize CURL" << std::endl;
        return;
    }

    std::string responseStr;
    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &responseStr);

    CURLcode res = curl_easy_perform(curl);
    if (res == CURLE_OK) {
        json response = json::parse(responseStr);
        std::cout << response["machineName"] << " => " << response["state"] << std::endl;
    } else {
        std::cerr << "Request failed: " << curl_easy_strerror(res) << std::endl;
    }

    curl_easy_cleanup(curl);
}
```
